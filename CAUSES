/* NEW THOUGHT (argh)
 * 1. Sometimes we choose a different selmon and focus its ->sel.
 *    (focusmon/selectmon)
 * 2. Sometimes we focus a different client and keep selmon.
 *    (focusclient/tostacktop/updatesel)
 * 3. Sometimes we move a client from one monitor to another without focus
 *    following it.
 * 4. However, sometimes we need to change selmon and *bring ->sel with us*.
 *
 * If we compose 4 = 1 + 2, then focus flickers briefly to new->sel.
 * If we compose 4 = 2 + 1, then focus flickers briefly to old->sel.
 *
 * What parts can we break these all into that will work for all cases?
 *
 * New focusmc(m, c): set selmon to m and selmon->sel to c, reattaching c to m
 * if needed?
 *
 * 1. Move client to another monitor with no focus change (i.e. selmon moves to
 * the other monitor as well).
 * 2. Select another monitor, with focus moving to m->sel.
 * 3. Select and move focus to another client on the same monitor.
 *
 * Okay.  We need to be able to:
 *  - Focus client c within the same selmon.
 *    . Raise client c to the top on its monitor and update focus.
 *  - Select (and maybe focus) the topmost (newly) visible client on a monitor.
 *    . Raise nextvisible(m->stack) to the top on its monitor and update focus.
 *  - Select a different monitor and focus its sel client.
 *    . Select monitor m, focusing its topmost client.
 *  - Focus client c on monitor m, changing focus to that monitor.
 *    . Raise client c to the top on its monitor.
 *    . Select monitor m, focusing its topmost client.
 *  - Send (the selected) client to another monitor, focusing the next on
 *    selmon.
 *    . Move c to m without changing focus.
 *    . Select original monitor, focusing its topmost client.
 *  - Send (the selected) client to another monitor, changing selmon to match
 *    and leaving focus on the same client.
 *    . Move c to m without changing focus.
 *
 * Invariant-preserving primitives:
 *  - updatesel(m): Update sel to match topmost client on monitor m, and give it
 *    focus as well if m == selmon.
 *  - focusclient(c): Raise a particular client to the top on its monitor, and
 *    if m == selmon, give it focus as well.
 *  - selectmon(m): Select a particular monitor, focusing its topmost client (or
 *    none).
 *  - moveto(c, m): Move client c to monitor m without changing focus.  If
 *    c == selmon->sel at start, then selmon = m by the end.
 */

// This function should change c->mon to m without causing the focus (i.e. the
// value of the expression selmon->sel) to change.  It will thus have the
// following before/after characteristics:
//   - Before: old == m
//     - After: no change needed
//   - Before: old != selmon and m != selmon
//     - After: no change to selmon, just attach c to m
//   - Before: old == selmon and c == old->sel
//     - After: m == selmon and c == m->sel
//   - Before: old == selmon and c != old->sel
//     - After: old == selmon and c == m->sel
//   - Before: m == selmon and m->sel != NULL
//     - After: attach c behind m->sel, no change to selmon or m->sel
//   - Before: m == selmon and m->sel == NULL
//     - WHAT DO - attaching c to m anywhere makes it the topmost visible.
//       Before this there is no client focused.  Preserving invariant forces us
//       to make a focus change here.
void
attachtosel(Client *c, Monitor *m)
{
	EXPECT(c);
	EXPECT(c->mon == selmon);
	EXPECT(c == selmon->sel);
	EXPECT(c == selmon->stack);
	Monitor *old = c->mon;
	if (old == m)
		return;

	detach(c);
	c->mon = m;
	c->next = m->clients;
	c->snext = m->stack;
	m->clients = m->stack = c;

	selmon = m;
	selmon->sel = c;

	updatesel(old);

	/* req: */
	//arrange(old);
	//drawbar(old);
	//arrange(m);
	//drawbar(m);
}

/* Set X focus, window border, grabbuttons */
/* Change m->sel */
/* Move client to stack top */
/* Focus different client on selmon */
/* Change selmon */

/* When you change monitor focus, this focuses a client.  That client should be 
 * tostacktop'd. */

/* Feel free to call updatesel(m) anytime you touch m->stack, m->tagset,
 * m->seltags, or c->tags */

/* Use selectmon(m) to change selmon */

/* Sloppy focus invariant: if the mouse is in a window, then it is focused; if
 * the mouse is not in a window, the MRU window is focused */

/* Behavior when current focus window becomes invalid, to preserve invariant:
 * either warp pointer to next visible MRU window (e.g. switching tags), or
 * focus window under pointer (closing floating window).  Tricky if next visible
 * MRU window is not raised - center of the window could be under another, in
 * which case the pointer isn't "in" the window.  Should we raise/restack at
 * this point?  Keep track of pointer coordinates last time this window was
 * focused?
 *
 * I think raise+warp will be good. */

void
xraiseclient(Client *c)
{
	XWindowChanges wc;

	if (c->isfloating)
		XRaiseWindow(dpy, c->win);
	else {
		wc.stack_mode = Below;
		wc.sibling = c->mon->barwin;
		XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
	}
	// From restack() in dwm.  Clears all EnterNotify events caused by
	// restacking windows from the queue.  Do we need this here?  The
	// consequence is that a call to xraiseclient can cause the raised
	// client to be focused, if it is under the pointer.  Moot if we only
	// raise a client when it is focused or we intend to focus it.
	//
	//XSync(dpy, False);
	//while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
}

void
xsetfocus(Client *c)
{
	XSetInputFocus(dpy, c ? c->win : root, RevertToPointerRoot, CurrentTime);
	if (!c) {
		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
		return;
	}
	if (!c->neverfocus)
		XChangeProperty(dpy, root, netatom[NetActiveWindow],
			XA_WINDOW, 32, PropModeReplace,
			(unsigned char *) &(c->win), 1);
	xsendevent(c, wmatom[WMTakeFocus]);
}

void
xfocus(Monitor *m)
{
	if (m != selmon)
		return;
	xsetfocus(m->sel); /* call this on NULL to set root focus */
	if (!m->sel)
		return;
	if (m->sel->isurgent)
		seturgent(m->sel, 0);
	xgrabbuttons(m->sel, 1);
	XSetWindowBorder(dpy, m->sel->win, scheme[SchemeSel][ColBorder].pixel);
}

void
xunfocus(m)
{
	if (m != selmon || !m->sel)
		return;
	xgrabbuttons(m->sel, 0);
	XSetWindowBorder(dpy, m->sel->win, scheme[SchemeNorm][ColBorder].pixel);
}

void /* IDEMPOTENT, requires call to drawbar(m) if m->sel changes */
updatesel(Monitor *m)
{
	Client *c = nextvisible(m->stack);
	if (m->sel == c)
		return;
	xunfocus(m);
	m->sel = c;
	xfocus(m);
}

void /* requires call to drawbar(m) if m->sel changes */
focusclient(Client *c)
{
	Client **tc;
	if (!c)
		return;

	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;
	c->snext = c->mon->stack;
	c->mon->stack = c;

	updatesel(c->mon);
}

void
selectmon(Monitor *m)
{
	if (selmon == m)
		return;
	old = selmon;
	focusclient(m->sel); /* bring to top of stack */
	xunfocus(selmon);
	selmon = m;
	xfocus(m);
	drawbar(old);

	drawbar(m); // <- req
}

void
focusmon(const Arg *arg)
{
	Monitor *m;
	if (!mons->next)
		return;
	m = dirtomon(arg->i);
	selectmon(m);
	drawbar(m);
}

void
focusstack(const Arg *arg)
{
	Client *c;
	if (!selmon->sel)
		return;
	c = arg->i > 0 ? nextvisclient(selmon->sel) : prevvisclient(selmon->sel);
	EXPECT(c); // since sel should be visible
	if (c == selmon->sel)
		return;
	focusclient(c);
	xraiseclient(c); // or restack(c->mon)
	drawbar(c->mon);
}

void
focusclientmon(Client *c, Monitor *m)
{
	EXPECT(c->mon == m);
	focusclient(c);
	selectmon(m);

	drawbar(m); // <- req
}

void
setclienttags(Client *c, unsigned int new)
{
	int vis;
	if (!c || !new || new == c->tags)
		return;
	vis = ISVISIBLE(c);
	c->tags = new;
	updatesel(c->mon);
	if vis != ISVISIBLE(c) {
		arrange(c->mon);
		showhide(c->mon->stack);
	}

	drawbar(m); // <- req
}

void
setmontags(Monitor *m, unsigned int new)
{
	if (!new || new == m->tagset[m->seltags])
		return;
	m->seltags ^= 1;
	m->tagset[m->seltags] = new;
	updatesel(m);

	arrange(m); // <- req
	showhide(m); // <- req
	drawbar(m); // <- req
}

void
tag(const Arg *arg)
{
	setclienttags(selmon->sel, arg->ui);
}

void
toggletag(const Arg *arg)
{
	if (selmon->sel)
		setclienttags(selmon->sel, selmon->sel->tags ^ arg->ui);
}

void
view(const Arg *arg)
{
	setmontags(selmon, arg->ui);
}

void
toggleview(const Arg *arg)
{
	setmontags(selmon, selmon->tags ^ arg->ui);
}

void
detach(Client *c)
{
	Client **tc;

	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;

	updatesel(c->mon);

	arrange(c->mon); // <-req
	drawbar(c->mon); // <-req
}

void
attachto(Client *c, Monitor *m)
{
	if (c->mon == m)
		return;
	if (c->mon) {
		detach(c); // calls updatesel(c->mon)
		arrange(c->mon); // <-req
		drawbar(c->mon); // <-req
	}
	if ((c->mon = m)) {
		c->next = c->mon->clients;
		c->snext = c->mon->stack;
		c->mon->clients = c->mon->stack = c;
		updatesel(m); // <-req
		arrange(m); // <-req
		showhide(m->stack); // <-req
		drawbar(m); // <-req
	}
}

void
tagmon(const Arg *arg)
{
	if (!selmon->sel || !mons->next)
		return;
	selmon->sel->tags = m->tags;
	attachto(selmon->sel, m);
}

void
toclienttop(Client *c)
{
	Client **tc;

	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	c->next = c->mon->clients;
	c->mon->clients = c;

	// arrange(c->mon); // <-req
}

void
zoom(const Arg *arg)
{
	Client *c = selmon->sel;

	if (!c || c->isfloating)
		return;
	if (c == nexttiled(selmon->clients))
		if (!(c = nexttiled(c->next)))
			return;
	toclienttop(c);
	// original dwm always focuses master after swap
	// focusclient(c);
	raiseclient(c);
	arrange(c->mon);
	// drawbar(c); // if focusclient above
}
