// # NOTES
// 
// - showhide makes no sense without arrange, because arrange depends on which
//   windows are visible, and any change in this also requires showhide
// 
// Invisible clients can be anywhere in the stack without affecting focus.  What
// do stack and focus look like when:
//  1. There are no visible clients.  No focus.  Stack is MRU.
//  2. There are visible clients, but none on selmon.  No focus.  Stack is MRU.
//  3. There are visible clients on selmon.  First on stack is on selmon, because
//     it was tostacktop'd when focused.
// 
// The following statements are equivalent:
//  - There is a focused client.
//  - There are visible clients on selmon.
//  - The X focus does not belong the root window.
//  - selmon->sel != NULL.
//  - VISIBLEON(stack, selmon).
// 
// The following statements are equivalent:
//  - Client c is focused.
//  - Client c is the MRU visible client on selmon.
//  - Client c has the "selected" border.
//  - The X focus belongs to c.
//  - selmon->sel == c.
//  - There is a focused client && stack == c.
//
// If we define the focused client as selmon->sel, then we can handily represent
// non-focus as well as focus.  However, it means we can't change selmon without
// first defocusing, which makes mousemove not so easy.
//
// If we define the focused client as stack, then we have to check
// (!stack || !VISIBLEON(stack, selmon)) rather than simply !selmon->sel, but it
// still represents non-focus.  We can change selmon now, but we cannot
// tostacktop without first defocusing.  Technically I think that is ok...
//
// THERE IS (currently) NO HARM in calling defocus() on something lacking focus!
//
// 
// Invariants:
//  - For any monitor m, m->sel == nextvisible(m, stack).  (denormalization)
//  - The X focus belongs to selmon->sel if not NULL, otherwise the root.
//    - Note: per ICCCM 4.1.10 advice, override-redirect (unmanaged) windows must
//      either grab the keyboard or piggyback on the focus of a managed window, so
//      we can assume that selmon->sel still "has focus"
// 
// Thoughts:
// - A client is raised in the stack only when it is focused/selected.
// - When a client is created:
//   - If VISIBLEON(client, selmon), it is placed at the top of the stack, which
//     triggers a focus change.
//   - If !VISIBLEON(client, selmon) and selmon->sel == NULL, it is placed at the
//     top of the stack, but will not affect focus.
//   - If !VISIBLEON(client, selmon) and selmon->sel != NULL, pick one:
//      1. It is placed second in the stack, behind selmon->sel.  (More consistent
//         with behavior when creating on selmon.)
//      2. It is placed at the bottom of the stack.  (More consistent with
//         definition of stack as "most recently focused.")

// Selmon is required because we need to be able to identify the selected
// monitor (not based on mouse position) even when there are no clients.  The
// alternative would be something like making a fake client for the "unselected"
// version of each monitor, but that seems like it would require a lot of
// special-casing.

// We need to be able to:
//  - Focus a particular client and monitor (enternotify, buttonpress)
//  - Focus a particular monitor and whatever is selected on it (buttonpress,
//    motionnotify, focusmon, maybe movemouse/resizemouse)
//     - Use this also for updatesel?!?
//  - Focus a particular client on the current monitor (focusstack)
//  - Focus whatever is selected (or should be selected) on the current monitor
//    (configurenotify, tagmon)
//
// Can we leave stack set to the previous focused client (if any) so that it can
// be used to defocus?  Note that it does no harm to defocus it if it was not
// visible/focused (and therefore nothing was), plus it does no harm to focus it
// if it is already focused.

// Primitives:
//  - tostacktop: brings a client to top of stack
//  - refocusmon: sets selmon and changes focus to nextvisible(selmon, stack)
//  - global variable sel or focus: currently focused client

// Nope.  We use other monitors' sel to get the title to draw on the bar.
	// What if we relax the "sel" invariant to include only selmon?  Can we
	// do away with other monitors' sel altogether?
	// !stack ==> !sel
	// stack && !VISIBLEON(stack, stack->mon) ==> !sel
	// stack && VISIBLEON(stack, stack->mon) ==> sel != NULL
	// Invariant: sel == stack || 
	// Invariant: !sel == (!stack || !VISIBLEON(stack, stack->mon))
	// Invariant: !sel || stack == sel
	// Invariant: !sel || selmon == sel->mon == stack->mon

// # EVENTS

static Client *focus;

// ## Structure/Substructure


// ## Input

void
keypress()
{
	// as-is
}


// ## Exposure

void
expose()
{
	// EXPECT(w is a barwin)
	// as-is
}


// ## FocusChange

void
focusin()
{
	// as-is
}


// ## Miscellany

void
mappingnotify()
{
	// as-is
}


// ## TODO

void
destroynotify()
{
	// as-is, check unmanage
}

void
unmapnotify()
{
	// as-is for now
	//  1. Check ICCCM/EWMH for Withdrawn rules
	//  2. Handle extra events when showhide changes to map/unmap
}

void
buttonpress()
{
	// ...
	if ((c == wintoclient(ev->window))) {
		EXPECT(m == c->mon);
		m->sel = c;
		raiseclient(c);
		// ...
	}
	selmon = m;
	refocus3();
	// ...
}

void
clientmessage()
{
	// as-is, write setfullscreen
}

void
configurenotify()
{
	// will want to take a look at updategeom
	// ...
	Client *c = nextvisible(selmon, stack);
	if (c != selmon->sel) {
		defocus(stack);
		enfocus(c);
		selmon->sel = c;
	}
	mons->sel = nextvisible(mons, stack); // if mons == selmon, details handled above
}

void
configurerequest()
{
	// as-is
}

void
enternotify()
{
	Monitor *m = NULL;
	// ...
	c = wintoclient(ev->window);
	if (c == selmon->sel)
		return;
	if (c) {
		selmon = c->mon;
		selmon->sel = c;
	} else
		selmon = wintomon(ev->window);

	refocus3();
}

void
maprequest()
{
	// as-is, write manage
}

void
motionnotify()
{
	static Monitor *mon = NULL;
	// ...
	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
		selmon = m;
		refocus3();
	}
	mon = m;
}

void
propertynotify()
{
	// as-is
}


// # COMMANDS

// ## Focus/order

void
focusstack(const Arg *arg)
{
	if (!selmon->sel)  // if (!stack || !VISIBLEON(stack, selmon))
		return;
	Client *c = nextclientindir(selmon, selmon->sel, arg->i);
	if (/* !c || */ c == selmon->sel)
		return;

	selmon->sel = c;
	refocus3();

	raiseclient(c); // or restack(c->mon);
	drawbar(c->mon);
}

void
focusmon(const Arg *arg)
{
	Monitor *old = selmon;
	Monitor *m = dirtomon(arg->i);
	if (m == selmon)
		return;
	selmon = m;
	refocus3();
	drawbar(old);
	drawbar(m);
}

void
refocusmon(Monitor *m)
{
	Client *newfocus = nextvisible(m, stack);
	selmon = m;
	if (newfocus == focus)
		return;
	defocus(stack);
	sel = newfocus;
	enfocus(sel);
}

void
zoom()
{
	// as-is
}


// ## Tag management

void
tag()
{
	// change tags of selected client
	if (selmon->sel)
		setclienttags(selmon->sel, arg->ui & TAGMASK);
}

void
toggletag()
{
	// XOR selected client's tags with arg
	if (selmon->sel)
		setclienttags(selmon->sel, selmon->sel->tags ^ (arg->ui & TAGMASK));
}

void
view()
{
	// change visible tags on m
	unsigned int new = (arg->ui & TAGMASK);
	if (!new)
		new = selmon->tagset[selmon->seltags ^ 1];
	setmontags(selmon, new);
}

void
toggleview()
{
	setmontags(selmon, selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK));
}

void
tagmon()
{
	// move client c to monitor new and maintain selmon
	sendto(c, m, 0);
}

void
movemouse() / resizemouse()
{
	// move client c to monitor new and maintain focus
	sendto(c, m, 1);
	raiseclient(c);

	arrange(oldmon);
	arrange(newmon);
	drawbar(oldmon);
	drawbar(newmon);
}


// ## Layout


// ## Miscellaneous

void
killclient()
{
	// as-is
}

void
quit()
{
	// as-is
}

void
spawn()
{
	// as-is
}

void
togglebar()
{
	// as-is, maybe later unmap barwin instead of moving
}

// ## TODO

void
incnmaster()
{
}

void
pushdown()
{
	if (!selmon->sel || selmon->sel->isfloating)
		return;
	if ((c = nexttiled(sel->next)))
		moveafter(sel, c);
	else
		moveafter(sel, NULL);
}

void
pushup()
{
}

void
setlayout()
{
}

void
setmfact()
{
}

void
togglefloating()
{
}


// # FUNCTIONS

// ## Focus

void
defocus(Client *c)
{
	if (!c) // XXX needed??
		return;
	grabbuttons(c, 0);
	xborder(c, NORM);
	// setxfocus(NULL) // should be followed by enfocus
}

void
enfocus(Client *c)
{
	// should be called after defocus
	setxfocus(c);
	if (!c)
		return;
	tostacktop(c);
	if (c->isurgent)
		seturgent(c, 0);
	grabbuttons(c, 1);
	xborder(c, SEL);
}

void
enfocus2(Client *c)
{
	// should be called after defocus
	setxfocus(c);
	if (!c)
		return;
	if (c->isurgent)
		seturgent(c, 0);
	grabbuttons(c, 1);
	xborder(c, SEL);
}

void
refocus(Monitor *m, Client *c)
{
	Client *oldfocus = selmon->sel;
	selmon = m;
	selmon->sel = c;
	if (oldfocus != selmon->sel) {
		defocus(stack);
		enfocus(selmon->sel);
	}
}

void
refocus2(Monitor *m, Client *c)
{
	Client *oldfocus = selmon->sel;
	selmon = m ? m : selmon;
	selmon->sel = c ? c : selmon->sel;
	if (selmon->sel != oldfocus) {
		defocus(stack);
		enfocus(selmon->sel);
	}
}

void
refocus3()
{
	if (selmon->sel != stack)
		defocus(stack);
	tostacktop(selmon->sel);
	enfocus2(selmon->sel);
}

void
updatesel(Monitor *m)
{
	m->sel = nextvisible(m, stack);
	refocus3();
}

void
selectmon(Monitor *m)
{
	if (m == selmon)
		return;
	defocus(stack);
	enfocus(m->sel);
	selmon = m;
}

void // if c == NULL, defocuses and leaves selmon as is
focusclient(Client *c)
{
	if (c == selmon->sel)
		return;
	defocus(stack);
	enfocus(c);
	if (c)
		selmon = c->mon;
	selmon->sel = c;
}

// ## Layout

void
raiseclient(Client *c)
{
	// as-is
}

// ## Tags/monitors

void
setclienttags(Client *c, unsigned int new)
{
	if (!new || new == c->tags)
		return;

	c->tags = new;
	updatesel(c->mon);
}

void
setmontags(Monitor *m, unsigned int new)
{
	if (!new || new == m->tagset[m->seltags])
		return;
	m->seltags ^= 1;
	m->tagset[m->seltags] = new;
	updatesel(m);
}

void
sendto(Client *c, Monitor *new, int keepfocus)
{
	// move client c to monitor new and maintain selmon or focus
	EXPECT(c);
	old = c->mon;
	if (old == new)
		return;

	if (selmon->sel == c && keepfocus)
		selmon = new;

	// Can move this below c->mon = new, change c->snext to stack, and
	// remove the if condition
	if (old->sel == c)
		old->sel = nextvisible(old, c->snext);
	c->tags = new->tags;
	c->mon = new;
	EXPECT(VISIBLEON(c, new));
	new->sel = nextvisible(new, stack);
	EXPECT(new->sel != NULL);

	refocus3();
}

// ## List management

Client *
nextvisible(Monitor *m, Client *c)
{
	for (; c && !VISIBLEON(c, m); c = c->snext);
	return c;
}

Client *
nexttiled(Monitor *m, Client *c)
{
	for (; c && (c->isfloating || !VISIBLEON(c, m)); c = c->next);
	return c;
}

Client *
prevtiled(Monitor *m, Client *c)
{
	Client *i, *p = NULL;
	for (i = clients; i && i != c; i = i->next)
		if (!i->isfloating && VISIBLEON(i, m))
			p = i;
	return p;
}

// ## Client management

void
unmanage(Client *c)
{
	// May be able to coax sendto(c, NULL) to do this bit
	EXPECT(c->mon != NULL);
	if (c == c->mon->sel) {
		Client *next = nextvisible(c->mon, stack);
		if (c->mon == selmon)
			defocus(stack); // == selmon->sel
		c->mon->sel = next;
		if (c->mon == selmon)
			enfocus(selmon->sel);
	}
	if (!destroyed) {
		// as-is
	}
	free(c);
	// ...
	// skip the raiseclient?
}

// vim:set ft=c:
