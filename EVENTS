# NOTES

- showhide makes no sense without arrange, because arrange depends on which
  windows are visible, and any change in this also requires showhide

# EVENTS

## Structure/Substructure

destroynotify:
	if !(c = wintoclient(w))
		return // not a managed window
	unmanage(c)

unmapnotify:
	if !(c = wintoclient(w)):
		return
	if (c->expect_unmap--):
		return
	setclientstate(c, WithdrawnState)
	unmanage(c)

## Input

keypress:
	as-is
## Exposure

expose:
	assert(w is a barwin)
	as-is

## FocusChange

focusin:
	as-is

## Miscellany

mappingnotify:
	as-is

## TODO

buttonpress:
clientmessage:
configurenotify:
configurerequest:
enternotify:
maprequest:
	if wintoclient(w):
		return // client tried to map again while hidden?
	c = newclient(w)
	attachto(c, selmon)

motionnotify:
	if ev->window != root:
		return
	focusmon(recttomon
propertynotify:

# COMMANDS

## Tag management

tag: // change tags of selected client
	setclienttags(new)

toggletag: // XOR selected client's tags with arg
	setclienttags(selmon->sel->tags ^ new)

view: // change visible tags on m
	setmontags(new)

toggleview:
	setmontags(selmon->tags ^ new)

tagmon: // change monitor of selected client (without following it)
	Client *c = selmon->sel;
	if !c || !mons->next:
		return

	new = nextvisible(c->snext)
	focusmc(selmon, new)
	? raiseclient(new) or restack(new->mon)
	// assert: selmon->sel != c

	newmon = monitor to send to
	c->tags = m->tags
	attachto(c, newmon)

	arrange(selmon)
	arrange(newmon)
	drawbar(selmon)
	drawbar(newmon)

## Focus/order

focusmon:
	// needs to set selmon even if no client on it
	focusmc(m, m->sel)
		
focusstack:
	new = next client to focus
	focusmc(new->mon, new)
	raiseclient(new) or restack(new->mon)

zoom:
	if (c->isfloating || !ISVISIBLE(c))
		return
	if (c == nexttiled(c->mon->clients))
		new = nexttiled(c->next)
	else
		new = c
	toclienttop(new)
	arrange(c->mon)
	// original dwm always focuses master after swap
	// focusmc(selmon, new)

## Layout

incnmaster:
	m->nmaster = new value
	arrange(m)

pushdown:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = nexttiled(sel->next)):
		moveafter(sel, c)
	else:
		moveafter(sel, NULL);

pushup:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = prevtiled(sel)):
		movebefore(sel, c)
	else:
		movebefore(sel, NULL)

setlayout:
	m->lt = lt
	arrange(m)

setmfact:
	m->mfact = new value
	arrange(m)

togglefloating:
	Client *c = selmon->sel
	if !c || c->isfullscreen || c->isfixed: // include isfixed here?
		return
	if (c->isfloating = !c->isfloating): // include isfixed here?
		resize(sel, x, y, w, h, 0)
	arrange(selmon)
	? raiseclient(sel) // restack(selmon)
	drawbar(selmon) // changed c->isfloating

## Miscellaneous

killclient:
	send Delete event to window

quit:
	running = 0

spawn:
	// as-is

togglebar:
	// as-is, maybe later unmap barwin instead of moving

## TODO

movemouse:
resizemouse:

# FUNCTIONS

## Focus

Thoughts:
- The monitor stack should represent the last-focused order of clients.
- A client is raised in this stack only if it is focused/selected.
  - A client may be *placed* at the top when created or sent to this monitor.
- If any client is focused, selmon is its monitor.
- Therefore we should only *raise* clients (tostacktop) in the stack on selmon.
  - A client may be *placed* into the stack of an unfocused monitor.
- Should raising a client tostacktop change selmon?  Or is c->mon == selmon a
  precondition for tostacktop?
- If any client is focused, it is visible.
- Therefore we will only *raise* clients (tostacktop) which are visible.
- Therefore the client passed to tostacktop will always become the first
  visible client in c->mon->stack == selmon->stack, so it should become
  selmon->sel.

focusmc(m, c):
	assert(m && (!c || c->mon == m))
	if m != selmon || c != selmon->sel: // needed??
		unfocussel()
		selectmon(m)
		selectclient(c)
		focussel()
		drawbar(m) // changed: c->isurgent, c->mon->sel, selmon

selectmon(m): // PRECONDITION: nothing is focused, NOTE: requires drawbar(selmon)
	if selmon != m:
		oldmon = selmon
		selmon = m
		drawbar(oldmon)

selectclient(c): // NOTE: c may be NULL, requires drawbar(selmon)
	// PRECONDITION: !c || c->mon == selmon
    tostacktop(c)
	if c:
		// arrange(c->mon) if layouts can move or restack based on sel

selectclient2(c):
    tostacktop(c)
    // arrange(selmon) if layouts care about sel

selectclient3(c, m): // also selects monitor
	selectmon(c ? c->mon : m)
    tostacktop(c)
	// arrange(selmon) if layouts care about sel

unselect(m):
	m->sel = NULL
	// arrange(m) if layouts can move or restack based on sel

focussel: // PRECONDITION: nothing is focused
	setxfocus(selmon->sel)
	if selmon->sel:
		if selmon->sel->isurgent:
			seturgent(selmon->sel, 0)
		grabbuttons(selmon->sel, 1)
		setborder(selmon->sel, Selected)

unfocussel:
	if selmon->sel:
		grabbuttons(selmon->sel, 0)
		setborder(selmon->sel, Normal)

## Layout

arrange(m):
	if !m->sel || !m->lt->arrange:
		return
	m->lt->arrange(m)

raiseclient(c):
	if c->isfloating:
		XRaiseWindow(c->win)
	else:
		XConfigureWindow(c->win, Below, c->mon->barwin)

showhide(c):
	// as in other, but
	XMapWindow(c->win)
	// or
	c->expect_unmap++;
	XUnmapWindow(c->win)

## Tags

setclienttags(new):
	if !selmon->sel || new == selmon->sel->tags || new == 0:
		return
	// assert: since selmon->sel != NULL, ISVISIBLE(selmon->sel)
	selmon->sel->tags = new
	if !ISVISIBLE(selmon->sel):
		focusmc(selmon, nextvisible(selmon->stack))
		arrange(selmon)
		showhide(selmon)
	drawbar(selmon) // changed: c->tags, maybe m->sel

setmontags:
	if new == selmon->tags || new == 0:
		return
	// assert: selmon->sel == NULL || ISVISIBLE(selmon->sel)
	selmon->tags = new
	if !selmon->sel || !ISVISIBLE(selmon->sel): // can this be simplified?
		focusmc(selmon, nextvisible(selmon->stack))
	arrange(selmon)
	showhide(selmon)
	drawbar(selmon)

## List management

attachto(c, m):
	if c->mon != m:
        if c->mon:
            detach(c);
        c->mon = m;
        if c->mon:
            c->next = c->mon->clients;
            c->mon->clients = c;

            c->snext = c->mon->stack;
            c->mon->stack = c;
            if ISVISIBLE(c):
                c->mon->sel = c;

detach(c): // PRECONDITION: c != c->mon->sel
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;

moveafter(c, prev):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	tc = prev ? &prev->next : &c->mon->clients;
	c->next = *tc;
	*tc = c;

movebefore(c, next):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->clients; *tc && *tc != next; tc = &(*tc)->next);
	c->next = next;
	*tc = c;

/* precondition (unneeded?): c->mon->lt->arrange != NULL */
nexttiled(c):
	for (/* c */; c && (c->isfloating || !ISVISIBLE(c)); c = c->next)
	return c

nexttiled(c):
	return c && (c->isfloating || !ISVISIBLE(c)) : nexttiled(c->next) : c;

nextvisible(c):
	for (/* c */; c && !ISVISIBLE(c); c = c->snext);
	return c

nextvisible(c):
	return c && !ISVISIBLE(c) ? nextvisible(c->next) : c;

prevtiled(c):
	Client *i, *p = NULL;
	for (i = selmon->clients; i && i != c; i = i->next)
		if (!i->isfloating && ISVISIBLE(i))
			p = i;
	return p;

tostacktop: // PRECONDITION: c->mon == selmon
    // NOTE: c may be NULL, which sets c->mon->sel to NULL
	Client **tc;

    if (c->mon->sel = c):
        for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
        *tc = c->snext;
        c->snext = c->mon->stack;
        c->mon->stack = c;


## Client management

// Preconditions:
//  c is unmapped+Withdrawn (or we are shutting down)
unmanage(c):
	if (c == c->mon->sel)
		focusmc(selmon, nextvisible(c->snext))
	detach(c)
	arrange(c->mon)
	destroyclient(c)
