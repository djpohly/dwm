# EVENTS

## TODO

buttonpress:
clientmessage:
configurenotify:
configurerequest:
destroynotify:
enternotify:
expose:
focusin:
keypress:
mappingnotify:
maprequest:
motionnotify:
propertynotify:
unmapnotify:

# COMMANDS

## Tag management

tag: // change tags of selected client
	setclienttags(new)

toggletag: // XOR selected client's tags with arg
	setclienttags(selmon->sel->tags ^ new)

view: // change visible tags on m
	setmontags(new)

toggleview:
	setmontags(selmon->tags ^ new)

tagmon: // change monitor of selected client (without following it)
	Client *c = selmon->sel;
	if !c || !mons->next:
		return

	new = nextvisible(c->snext)
	focusclient(new)
	? raiseclient(new) or restack(new->mon)
	// assert: selmon->sel != c

	newmon = monitor to send to
	attachto(c, newmon)
	c->tags = m->tags

	arrange(selmon)
	arrange(newmon)
	drawbar(selmon)
	drawbar(newmon)

## Focus/order

focusmon:
	new = m->sel
	focusclient(m->sel)
		
focusstack:
	new = next client to focus
	focusclient(new)
	raiseclient(new) or restack(new->mon)

zoom:
	if (c->isfloating || !ISVISIBLE(c))
		return
	if (c == nexttiled(c->mon->clients))
		new = nexttiled(c->next)
	else
		new = c
	toclienttop(new)
	arrange(c->mon)
	// original dwm always focuses master after swap
	// focusclient(new)

## Layout

incnmaster:
	m->nmaster = new value
	arrange(m)

pushdown:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = nexttiled(sel->next)):
		moveafter(sel, c)
	else:
		moveafter(sel, NULL);

pushup:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = prevtiled(sel)):
		movebefore(sel, c)
	else:
		movebefore(sel, NULL)

setlayout:
	m->lt = lt
	arrange(m)

setmfact:
	m->mfact = new value
	arrange(m)

togglefloating:
	Client *c = selmon->sel
	if !c || c->isfullscreen || c->isfixed: // include isfixed here?
		return
	if (c->isfloating = !c->isfloating): // include isfixed here?
		resize(sel, x, y, w, h, 0)
	arrange(selmon)
	? raiseclient(sel) // restack(selmon)
	drawbar(selmon) // changed c->isfloating

## Miscellaneous

killclient:
	send Delete event to window

quit:
	running = 0

spawn:
	// as-is

togglebar:
	// as-is, maybe later unmap barwin instead of moving

## TODO

movemouse:
resizemouse:

# FUNCTIONS

arrange(m):
	if !m->sel || !m->lt->arrange:
		return
	m->lt->arrange(m)

detach(c):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;

focusclient(c):
	old = selmon->sel
	if c == old:
		return

	grabkeys(old, 0)
	setborder(old, Normal)

	setxfocus(c);
	if !c:
		c->mon->sel = c
		drawbar(c->mon);
		return

	if c->isurgent:
		seturgent(c, 0)
	grabkeys(c, 1)
	setborder(c, Selected)

	c->mon->sel = c
	if (selmon != c->mon)
		oldmon = selmon
		selmon = c->mon
		drawbar(oldmon) // changed: selmon

	tostacktop(c)
	// arrange(c->mon) if layouts can move or restack based on focus
	drawbar(c->mon) // changed: c->isurgent, c->mon->sel, selmon

moveafter(c, prev):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	tc = prev ? &prev->next : &c->mon->clients;
	c->next = *tc;
	*tc = c;

movebefore(c, next):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->clients; *tc && *tc != next; tc = &(*tc)->next);
	c->next = next;
	*tc = c;

/* precondition (unneeded?): c->mon->lt->arrange != NULL */
nexttiled(c):
	for (/* c */; c && (c->isfloating || !ISVISIBLE(c)); c = c->next)
	return c

nextvisible(c):
	for (/* c */; c && !ISVISIBLE(c); c = c->snext);
	return c

prevtiled(c):
	Client *i, *p = NULL;
	for (i = selmon->clients; i && i != c; i = i->next)
		if (!i->isfloating && ISVISIBLE(i))
			p = i;
	return p;

raiseclient(c):
	if c->isfloating:
		XRaiseWindow(c->win)
	else:
		XConfigureWindow(c->win, Below, c->mon->barwin)

setclienttags(new):
	if new == 0 || new == selmon->sel->tags:
		return
	selmon->sel->tags = new
	if !ISVISIBLE(selmon->sel): // assuming it was visible before
		// not visible anymore
		focusclient(nextvisible(selmon->stack))
		arrange(selmon)
		showhide(selmon)
	drawbar(selmon) // changed: c->tags, maybe m->sel

setmontags:
	if new == 0 || new == selmon->tags:
		return
	selmon->tags = new
	arrange(selmon)
	showhide(selmon)
	drawbar(selmon)

tostacktop:
	Client **tc;

	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;
	c->snext = c->mon->stack;
	c->mon->stack = c;
