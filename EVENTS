# NOTES

- showhide makes no sense without arrange, because arrange depends on which
  windows are visible, and any change in this also requires showhide

# EVENTS

## Structure/Substructure

destroynotify:
	if !(c = wintoclient(w))
		return // not a managed window
	unmanage(c)

unmapnotify:
	if !(c = wintoclient(w)):
		return
	if (c->expect_unmap--):
		return
	setclientstate(c, WithdrawnState)
	unmanage(c)

## Input

keypress:
	as-is
## Exposure

expose:
	assert(w is a barwin)
	as-is

## FocusChange

focusin:
	as-is

## Miscellany

mappingnotify:
	as-is

## TODO

buttonpress:
clientmessage:
configurenotify:
configurerequest:
enternotify:
maprequest:
	if wintoclient(w):
		return // client tried to map again while hidden?
	c = newclient(w)
	attachto(c, selmon)

motionnotify:
	if ev->window != root:
		return
	focusmon(recttomon
propertynotify:

# COMMANDS

## Tag management

tag: // change tags of selected client
	setclienttags(selmon->sel, new)

toggletag: // XOR selected client's tags with arg
	setclienttags(selmon->sel, selmon->sel->tags ^ new)

view: // change visible tags on m
	setmontags(selmon, new)

toggleview:
	setmontags(selmon, selmon->tags ^ new)

tagmon: // change monitor of selected client (without following it)
	Client *c = selmon->sel;
	if !c || !mons->next:
		return

	new = nextvisible(c->snext)
	focusmc(selmon, new)
	? raiseclient(new) or restack(new->mon)
	// assert: selmon->sel != c

	newmon = monitor to send to
	c->tags = m->tags
	attachto(c, newmon)

	arrange(selmon)
	arrange(newmon)
	drawbar(selmon)
	drawbar(newmon)

## Focus/order

focusmon:
	// needs to set selmon even if no client on it
	focusmc(m, m->sel)
		
focusstack:
	new = next client to focus
	focusmc(new->mon, new)
	raiseclient(new) or restack(new->mon)

zoom:
	if (c->isfloating || !ISVISIBLE(c))
		return
	if (c == nexttiled(c->mon->clients))
		new = nexttiled(c->next)
	else
		new = c
	toclienttop(new)
	arrange(c->mon)
	// original dwm always focuses master after swap
	// focusmc(selmon, new)

## Layout

incnmaster:
	m->nmaster = new value
	arrange(m)

pushdown:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = nexttiled(sel->next)):
		moveafter(sel, c)
	else:
		moveafter(sel, NULL);

pushup:
	if !sel || sel->isfloating || !ISVISIBLE(sel):
		return
	if (c = prevtiled(sel)):
		movebefore(sel, c)
	else:
		movebefore(sel, NULL)

setlayout:
	m->lt = lt
	arrange(m)

setmfact:
	m->mfact = new value
	arrange(m)

togglefloating:
	Client *c = selmon->sel
	if !c || c->isfullscreen || c->isfixed: // include isfixed here?
		return
	if (c->isfloating = !c->isfloating): // include isfixed here?
		resize(sel, x, y, w, h, 0)
	arrange(selmon)
	? raiseclient(sel) // restack(selmon)
	drawbar(selmon) // changed c->isfloating

## Miscellaneous

killclient:
	send Delete event to window

quit:
	running = 0

spawn:
	// as-is

togglebar:
	// as-is, maybe later unmap barwin instead of moving

## TODO

movemouse:
resizemouse:

# FUNCTIONS

## Focus

Thoughts:
- The monitor stack should represent the last-focused order of clients.
- A client is raised in this stack only if it is focused/selected.
  - A client may be *placed* at the top when created or sent to this monitor.
- If any client is focused, selmon is its monitor.
- Therefore we should only *raise* clients (tostacktop) in the stack on selmon.
  - A client may be *placed* into the stack of an unfocused monitor.
- Should raising a client tostacktop change selmon?  Or is c->mon == selmon a
  precondition for tostacktop?
- If any client is focused, it is visible.
- Therefore we will only *raise* clients (tostacktop) which are visible.
- Therefore the client passed to tostacktop will always become the first
  visible client in c->mon->stack == selmon->stack, so it should become
  selmon->sel.
- WAIT: changing tags on an unfocused monitor should change its ->sel also;
  should selectclient be used for this?

Car thoughts:
- Invariants:
  - m->sel is the most recently selected visible client in m's stack, or NULL if none is visible
  - The X focus belongs to selmon->sel if not NULL, otherwise the root
  - The selected border follows the X focus
  - The focused client is always first in selmon->stack
- Updates to the model:
  - Changing m->sel from old to new (old != new)
    - If m == selmon && old != NULL, unfocus old
    - If m == selmon && new != NULL, focus new
    - Should cause drawbar(m)
  - Changing selmon from old to new (old != NULL, new != NULL)
    - If old->sel != NULL, unfocus old->sel
    - If new->sel != NULL, focus new->sel
    - Should cause drawbar(old) and drawbar(new)
  - Changing both selmon (from m1 to m2) and sel (from c1 to c2) at once
    - Set m2->sel to c2
  - Detaching c from m
    - Should cause a focus transition if c == selmon->sel
    - Should cause drawbar(m)
  - Attaching c to m
    - Should set m->sel
- What can cause m->sel to change:
  - No longer most recent due to another client on m being selected (enternotify, focusstack, visible attachto)
  - No longer visible (client tags, monitor tags)
  - No longer in m's stack (change monitor, unmanage)
- To focus a different client on selmon:
  - Set selmon->sel to client

setselandmon(m, c): // PRECONDITION: !c || c->mon == m
	//setsel(m, c)
	EXPECT(!c || c->mon == m);
	if c && c == selmon->sel:
		return
	if !c && selmon->sel == NULL && selmon == m:
		return
	if m->sel != c:
		if m == selmon:
			if m->sel:
				unfocus(m->sel);
			if c:
				focus(c);
		tostacktop(c)
	if selmon != m:
		oldmon = selmon
		drawbar(oldmon)
		selmon = m
	drawbar(selmon)

// Decide whether you ask to change sel, and that affects m->stack, or
// you ask to change m->stack, and that affects sel

focusclient(c):
	EXPECT(c->mon == selmon)
	tostacktop_nosetsel(c)
	fixsel(m)

fixsel(m):
	new = nextvisible(m->stack)
	if m->sel != new:
		if m == selmon:
			unfocussel()
		m->sel = new
		if m == selmon:
			focussel()

// Does this work when:
// âœ“ c == m->sel (no change)
// - c != m->sel && m != selmon (no focus change, fixing sel)
// - c != m->sel && m == selmon && c == NULL
// - c != m->sel && m == selmon && c != m->sel && m->sel == NULL
// - c != m->sel && m == selmon && c != m->sel && m->sel != NULL
setsel(m, c): // requires drawbar(m) if m->sel != c
	EXPECT(!c || c->mon == m);
	if m->sel != c:
		if m == selmon:
			unfocussel();
		m->sel = c;
		if m == selmon:
			focussel()
		// arrange(m) if m->sel affects arrange

setselmon(m):
	if selmon != m:
		oldmon = selmon
		drawbar(oldmon)
		selmon = m
		drawbar(selmon)

focusmc(m, c):
	assert(m && (!c || c->mon == m))
	if m != selmon || c != selmon->sel: // needed??
		unfocussel_old(m) // no-op if m != selmon
		selectmon(m) // no-op if m == selmon
		selectclient(c)
		focussel() // no-op if m != selmon
		drawbar(m) // changed: c->isurgent, c->mon->sel, selmon

focusclient(c):
	EXPECT(c->mon == selmon);
	if c != selmon->sel:
		unfocussel()
		tostacktop2(selmon, c);
		focussel()
		drawbar(m)

selectmon(m): // PRECONDITION: nothing is focused, NOTE: requires drawbar(selmon)
	if selmon != m:
		oldmon = selmon
		selmon = m
		drawbar(oldmon)

selectclient(c): // NOTE: c may be NULL, requires drawbar(selmon)
	// PRECONDITION: !c || c->mon == selmon
	tostacktop(c)
	if c:
		// arrange(c->mon) if layouts can move or restack based on sel

selectclient2(c):
	tostacktop(c)
	// arrange(selmon) if layouts care about sel

selectclient3(c, m): // also selects monitor
	selectmon(c ? c->mon : m)
	tostacktop(c)
	// arrange(selmon) if layouts care about sel

unselect(m):
	m->sel = NULL
	// arrange(m) if layouts can move or restack based on sel

focussel(): // PRECONDITION: nothing is focused
	setxfocus(selmon->sel)
	if selmon->sel:
		if selmon->sel->isurgent:
			seturgent(selmon->sel, 0)
		grabbuttons(selmon->sel, 1)
		setborder(selmon->sel, Selected)

unfocussel_old(m):
	if m != selmon || !m->sel:
		return
	grabbuttons(m->sel, 0)
	setborder(m->sel, Normal)

unfocussel(m):
	if selmon->sel:
		grabbuttons(selmon->sel, 0)
		setborder(selmon->sel, Normal)

## Layout

arrange(m):
	if !m->sel || !m->lt->arrange:
		return
	m->lt->arrange(m)

raiseclient(c):
	if c->isfloating:
		XRaiseWindow(c->win)
	else:
		XConfigureWindow(c->win, Below, c->mon->barwin)

showhide(c):
	// as in other, but
	XMapWindow(c->win)
	// or
	c->expect_unmap++;
	XUnmapWindow(c->win)

## Tags

setclienttags(c, new):
	if !c || new == c->tags || new == 0:
		return
	wasvisible = ISVISIBLE(c)
	c->tags = new
	setsel(c->mon, nextvisible(c->mon->stack))
	if ISVISIBLE(c) != wasvisible:
		arrange(c->mon)
		showhide(c->mon)
	drawbar(c->mon) // changed: c->tags

setmontags(m, new):
	if new == m->tags || new == 0:
		return
	// assert: m->sel == NULL || ISVISIBLE(m->sel)
	m->tags = new
	// It is possible that the tag change may make a more recently
	// focused client visible, requiring that m->sel be updated.  This will
	// not happen when m == selmon, because selmon->sel is always the
	// first client in selmon's stack.
	setsel(m, nextvisible(m->stack))
	arrange(m)
	showhide(m)
	drawbar(m) // changed: m->tags

## List management

attachto(c, m):
	if c->mon != m:
		if c->mon:
			detach(c);
		c->mon = m;
		if c->mon:
			c->next = c->mon->clients;
			c->mon->clients = c;

			c->snext = c->mon->stack;
			c->mon->stack = c;
			if ISVISIBLE(c):
				c->mon->sel = c;

detach(c): // PRECONDITION: c != c->mon->sel
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
	*tc = c->snext;

moveafter(c, prev):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	tc = prev ? &prev->next : &c->mon->clients;
	c->next = *tc;
	*tc = c;

movebefore(c, next):
	Client **tc;
	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
	*tc = c->next;
	for (tc = &c->mon->clients; *tc && *tc != next; tc = &(*tc)->next);
	c->next = next;
	*tc = c;

/* precondition (unneeded?): c->mon->lt->arrange != NULL */
nexttiled(c):
	for (/* c */; c && (c->isfloating || !ISVISIBLE(c)); c = c->next)
	return c

nexttiled(c):
	return c && (c->isfloating || !ISVISIBLE(c)) : nexttiled(c->next) : c;

nextvisible(c):
	for (/* c */; c && !ISVISIBLE(c); c = c->snext);
	return c

nextvisible(c):
	return c && !ISVISIBLE(c) ? nextvisible(c->next) : c;

prevtiled(c):
	Client *i, *p = NULL;
	for (i = selmon->clients; i && i != c; i = i->next)
		if (!i->isfloating && ISVISIBLE(i))
			p = i;
	return p;

tostacktop(c):
	// NOTE: c may be NULL, which sets selmon->sel to NULL
	Client **tc;

	if c:
		c->mon->sel = c;
		for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
		*tc = c->snext;
		c->snext = c->mon->stack;
		c->mon->stack = c;
	else
		selmon->sel = NULL

tostacktop2(m, c): // PRECONDITION: c == NULL || m == c->mon
	// NOTE: c may be NULL, which sets m->sel to NULL
	// if m != c->mon, this reattaches
	Client **tc;

	if (m->sel = c):
		for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
		*tc = c->snext;
		c->snext = m->stack;
		m->stack = c;


## Client management

// Preconditions:
//  c is unmapped+Withdrawn (or we are shutting down)
unmanage(c):
	if (c == c->mon->sel)
		focusmc(selmon, nextvisible(c->snext))
	detach(c)
	arrange(c->mon)
	destroyclient(c)
